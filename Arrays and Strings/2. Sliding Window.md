```md
Like two pointers, sliding windows work the same with arrays and strings - the important thing is that they're iterables with ordered elements.
```
Implemented using two pointers! 
### Subarrays
Given an array, a subarray is a contiguous section of the array. All the elements must be adjacent to each other in the original array and in the original order. 

[1, 2, 3, 4]
[1], [2], [3], [4]
[1, 2], [2, 3], [3, 4]
[1,2,3], [2, 3, 4]
[1, 2, 3, 4]

A subarray can be defined by two indices, the start and the end 
for example 
[2, 3] has a starting index of `1` and `2` 
We call the starting index **left bound**
We call the ending index **right bound**
**Another name for subarray is window**

[3, 6, 2, 8, 1,  4, 1, 5] -> [2, 8, 1, 4]
left = 2    right = 5

### When should we use sliding window? 
#### First 
The problem will either explicitly or implicitly define criteria that make a subarray "valid"
1. A constraint metric (some attribute of the subarray, sum, # of unique elements, frequency of a specific element...)
2. A numeric restriction on the constrain metric 

For example, a problem declares a subarray is valid if it has a sum <= 10. The `constraint metric` here is the `sum of the subarray`, the `numeric restriction` is `<= 10`

#### Second
The problem will ask you to find valid subarrays in some way 
1. The most common task you will see is finding the best valid subarray. The problem will define what makes a subarray better than another. For example, a problem might ask you to find the longest valid subarray
2. Another common task is finding the number of valid subarrays

`Whenever a problem description talks about subarrays, you should figure out if sliding window is a good option by analyzing the problem description. If you can find the things mentioned above, then go for it`

* Find the longest subarray with a sum less than or equal to `k`
* Find the longest substring that has at most on `"0"`
* Find the number of subarrays that have a product less than `k`

### The algorithm
Consider only `valid` subarrays. A subarray can be defined by a left bound and a right bound. In sliding window, we maintain `left` and `right` variables representing the current subarray. 
Initially `left = right = 0` (the first subarray we look at is just the first element of the array on its own).
We want to expand the size of our "window" by incrementing `right`
If after adding a new element (incrementing right), our subarray becomes invalid? We need to "remove" some elements from our window until it becomes valid again. To do that, increment `left`, which shrinks our window. 

##### Example
a positive integer array `nums` and an integer `k`
Find the length of the longest subarray that has a sum less than or equal to `k`
`nums=[3, 2, 1, 3, 1, 1]`  and `k = 5`

`left = right = 0`
window: [3]
`left = 0 right = 1`
window: [3, 2]
`left = 0 right = 2`
window [3, 2, 1] (constraint is broken: 6 > k)
`left = 1, right = 2`
window [2, 1]
... 
Why is it ok to remove `3` and "forget about it" for the rest of the algorithm? 
Because the input only has positive integers, a longer subarray directly equals a larger sum. 
### Implementation
We need to identify a `constraint metric` 
(in our example, this is the sum of the window)
We can keep track of our window in a separate array (adding and removing from our array), we can always find the sum of our current window just by summing the elements in the separate array. - This is `very inefficient`  - finding the sum will be `O(n)`

We don't want to store the window in a separate array. We just need a variable `curr`, that keeps trakc of the current sum. When we add a new element from the right we just do `curr += nums[right]` when we remove `curr -= nums[left]`. Now all operations are `O(1)`

How do we move the pointers `left` and `right`? 
We can use a for loop - we are always moving right, we only move left if the window becomes invalid. We need to maintain `curr <= k` this suggests we use a while loop for the removals
`while (curr > k)` -> `curr -= nums[left]`  -> `left++`

Finally, how do we update the answer? `right - left + 1`

```python
function fn(nums, k): 
	left = 0
	curr = 0
	answer = 0
	for (int right = 0; right < nums.length; right++):
		curr += nums[right]
		while (curr > k) :
			curr -= nums[left]
			left++
		answer = max(answer, right - left + 1)
	return answer
```

##### General template pseudocode 
```python 
function fn(arr):
	left = 0
	for(int right = 0; right < arr.length; right++):
		Do some logic to "add" element at arr[right] to window
		while WINDOW_IS_INVALID:
			Do some logic to "remove" element at arr[left] from window
			left++
		Do some logic to update the answer
```

##### Example 1: Given an array of positive integers nums and an integer k, find the longest subarray whose sum is less than or equal to k.

```java
public int longestSubarray(int[] nums, int k) {
	int left = 0;
	int right = 0;
	int curr = 0;
	int answer = 0;
	for(right = 0; right < nums.length; right++) { 
		curr += nums[right];
		while(curr > k) { 
			curr -= nums[left];
			left++;
		}
		answer = Math.max(answer, right - left + 1);
	}
	return answer;
}
```

###### Example 2: Given a binary string s, you may choose up to one "0" and flip it to a "1". What is the length of the longest substring achievable that contains only "1"?  For example, given s = "1101100111", the answer is 5. Perform the flip at index 2 - [11111]0011
```java
public int findLength(String s) { 
	// curr is the number of zeros in the window
	int left = 0;
	int curr = 0;
	int ans = 0;
;;;;;;;
	for(int right = 0; right < s.length(); right++) { 
		if(s.charAt(right) == '0') { 
			curr++;
		}
		while(curr > 1) { 
			if(s.charAt(left) == '0') {
				curr--;
			}
			left++;
		}
		ans = Math.max(ans, right - left + 1);
	}
	return ans; 
}
```